import { GoogleGenAI, Type } from "@google/genai";
import { InvoiceData } from "../types";
import { COMMON_HSN_MAP } from "../constants";

// NOTE: In a production app, this key should be handled via a proxy server 
// or strictly environment variables.
const API_KEY = process.env.API_KEY || '';

export const parseInvoiceRequest = async (
  promptText: string,
  currentInvoice: InvoiceData
): Promise<Partial<InvoiceData>> => {
  if (!API_KEY) {
    throw new Error("API Key is missing. Please configure process.env.API_KEY.");
  }

  // Use 'gemini-3-flash-preview' for basic text tasks as per guidelines.
  const modelId = "gemini-3-flash-preview";
  const ai = new GoogleGenAI({ apiKey: API_KEY });
  
  const systemInstruction = `
    You are an expert Indian GST Invoicing Assistant.
    Extract structured invoice data from natural language.

    RULES:
    1. **Buyer**: Identify who the invoice is for (Client/Customer). Extract Name, GSTIN, Address, State.
       - Infer State from City if needed (e.g. Mumbai -> Maharashtra).
    2. **Items**: 
       - Extract 'Description' (support multi-line details, keep it professional).
       - Extract 'Qty', 'Rate'.
       - **HSN Code**: You MUST predict a valid 4-6 digit HSN code based on the item description. Do NOT leave this empty for goods.
       - **GST Rate**: Predict standard GST rates (0, 5, 12, 18, 28) based on item type if not specified (Default to 18).
    3. **Metadata**: 
       - Extract Invoice No if explicitly mentioned. If NOT mentioned, do NOT return a null value; omit the field so the system keeps the existing one.
       - Extract Invoice Date if present.
    4. **Formatting**:
       - Ensure strictly JSON output.
       - Add a disclaimer field in the response stating: "Generated by AI. Verify HSN & Tax rates."

    OUTPUT: Structured JSON only.
  `;

  try {
    const response = await ai.models.generateContent({
      model: modelId,
      contents: promptText,
      config: {
        systemInstruction: systemInstruction,
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            buyer: {
              type: Type.OBJECT,
              properties: {
                name: { type: Type.STRING },
                gstin: { type: Type.STRING },
                address: { type: Type.STRING },
                state: { type: Type.STRING },
                pan: { type: Type.STRING },
                email: { type: Type.STRING },
                phone: { type: Type.STRING },
              }
            },
            invoiceNumber: { type: Type.STRING, description: "Only if explicitly in prompt, else omit" },
            invoiceDate: { type: Type.STRING, description: "YYYY-MM-DD" },
            items: {
              type: Type.ARRAY,
              items: {
                type: Type.OBJECT,
                properties: {
                  description: { type: Type.STRING, description: "Detailed item description" },
                  qty: { type: Type.NUMBER },
                  rate: { type: Type.NUMBER },
                  hsn: { type: Type.STRING },
                  gstRate: { type: Type.NUMBER },
                }
              }
            },
            invoiceType: { type: Type.STRING },
            aiDisclaimer: { type: Type.STRING }
          }
        }
      }
    });

    const text = response.text;
    if (!text) return {};

    const parsed = JSON.parse(text);
    
    // Transform AI response to partial InvoiceData
    const updates: Partial<InvoiceData> = {};

    if (parsed.buyer) {
      const buyerUpdates: any = {};
      if (parsed.buyer.name) buyerUpdates.name = parsed.buyer.name;
      if (parsed.buyer.gstin) buyerUpdates.gstin = parsed.buyer.gstin;
      if (parsed.buyer.address) buyerUpdates.address = parsed.buyer.address;
      if (parsed.buyer.state) buyerUpdates.state = parsed.buyer.state;
      if (parsed.buyer.pan) buyerUpdates.pan = parsed.buyer.pan;
      if (parsed.buyer.email) buyerUpdates.email = parsed.buyer.email;
      if (parsed.buyer.phone) buyerUpdates.phone = parsed.buyer.phone;

      updates.buyer = {
        ...currentInvoice.buyer,
        ...buyerUpdates
      };
    }

    // Only update invoice number if valid string returned and not "null"
    if (parsed.invoiceNumber && parsed.invoiceNumber !== "null" && parsed.invoiceNumber.trim() !== "") {
      updates.invoiceNumber = parsed.invoiceNumber;
    }

    if (parsed.invoiceDate) updates.invoiceDate = parsed.invoiceDate;

    if (parsed.items && Array.isArray(parsed.items) && parsed.items.length > 0) {
      updates.items = parsed.items.map((item: any, index: number) => {
        // Fallback HSN Logic: Use AI provided, or lookup Map, or default empty
        let hsn = item.hsn || "";
        if (!hsn && item.description) {
            const descLower = item.description.toLowerCase();
            for (const [key, code] of Object.entries(COMMON_HSN_MAP)) {
                if (descLower.includes(key)) {
                    hsn = code;
                    break;
                }
            }
        }

        return {
          id: `ai-${Date.now()}-${index}`,
          description: item.description || "Item",
          qty: item.qty || 1,
          rate: item.rate || 0,
          hsn: hsn,
          gstRate: item.gstRate || 18
        };
      });
    }
    
    return updates;

  } catch (error: any) {
    console.error("AI Parsing Error:", error);
    
    // Check for specific Quota Exceeded / Rate Limit errors
    // The library or API might return it in various structures, checking common properties
    const errorMsg = error.message || JSON.stringify(error);
    if (
        error.status === 429 || 
        error.code === 429 || 
        errorMsg.includes('429') || 
        errorMsg.includes('quota') ||
        errorMsg.includes('RESOURCE_EXHAUSTED')
    ) {
       throw new Error("QUOTA_EXCEEDED");
    }
    
    throw error;
  }
};